#![warn(missing_docs)]
//! # local-guard-upload
//!
//! ## Purpose
//! Implements protected ingest upload semantics with idempotency and retries.
//!
//! ## Responsibilities
//! - Enforce HTTPS endpoint policy.
//! - Build deterministic idempotency keys per payload.
//! - Retry transient failures using capped exponential backoff with jitter.
//! - Classify failures for UI and telemetry projection.
//!
//! ## Data flow
//! `MosaicPayload` -> idempotency key generation -> transport upload attempts ->
//! [`UploadReport`] surfaced to app runtime.
//!
//! ## Ownership and lifetimes
//! Payload bytes are owned by caller. Upload client borrows payload for each
//! retry attempt and never mutates source content.
//!
//! ## Error model
//! Upload errors are categorized as retriable or permanent with
//! [`FailureClass`], enabling safe retry loops.
//!
//! ## Security and privacy notes
//! Requires HTTPS endpoint and non-empty bearer tokens.
//! Token values are never embedded in errors.

use std::sync::Arc;

use local_guard_core::MosaicPayload;
use sha2::{Digest, Sha256};
use thiserror::Error;
use url::Url;

/// Upload failure class used by retry policy.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub enum FailureClass {
    /// Caller may retry with backoff.
    Retriable,
    /// Retry should stop and surface error.
    Permanent,
}

/// Configurable retry behavior.
#[derive(Debug, Clone, Copy, PartialEq, Eq)]
pub struct RetryPolicy {
    /// Maximum number of retries after first attempt.
    pub max_retries: u32,
    /// Base delay in milliseconds.
    pub base_delay_ms: u64,
    /// Max delay cap in milliseconds.
    pub max_delay_ms: u64,
    /// Jitter spread in milliseconds.
    pub jitter_ms: u64,
}

impl RetryPolicy {
    /// Returns default policy for MVP upload path.
    pub fn mvp_default() -> Self {
        Self {
            max_retries: 3,
            base_delay_ms: 250,
            max_delay_ms: 2_500,
            jitter_ms: 100,
        }
    }

    /// Computes deterministic capped exponential backoff.
    pub fn backoff_delay_ms(&self, attempt_index: u32) -> u64 {
        let exponential = self
            .base_delay_ms
            .saturating_mul(2_u64.saturating_pow(attempt_index));
        let capped = exponential.min(self.max_delay_ms);
        let jitter = if self.jitter_ms == 0 {
            0
        } else {
            // Deterministic jitter keeps tests stable.
            (attempt_index as u64 * 31) % self.jitter_ms
        };
        capped.saturating_add(jitter)
    }
}

/// Upload request context generated by client.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct UploadEnvelope {
    /// Destination endpoint URL.
    pub endpoint: String,
    /// Authorization header value (`Bearer <token>`).
    pub authorization_header: String,
    /// Idempotency key associated with payload.
    pub idempotency_key: String,
    /// JSON payload body.
    pub body: Vec<u8>,
}

/// Upload result details for observability.
#[derive(Debug, Clone, PartialEq, Eq)]
pub struct UploadReport {
    /// Number of attempts performed.
    pub attempts: u32,
    /// Final outcome class.
    pub final_class: Option<FailureClass>,
}

/// Upload transport abstraction implemented by concrete HTTP client.
pub trait UploadTransport: Send + Sync {
    /// Sends one upload attempt.
    fn send(&self, envelope: &UploadEnvelope) -> Result<(), UploadError>;
}

/// Protected ingest upload client.
#[derive(Clone)]
pub struct UploadClient {
    endpoint: String,
    policy: RetryPolicy,
    transport: Arc<dyn UploadTransport>,
}

impl UploadClient {
    /// Creates an upload client with endpoint validation.
    ///
    /// # Errors
    /// Returns [`UploadError::InvalidEndpoint`] for malformed URLs.
    /// Returns [`UploadError::NonHttpsEndpoint`] for non-HTTPS URLs.
    pub fn new(
        endpoint: impl Into<String>,
        policy: RetryPolicy,
        transport: Arc<dyn UploadTransport>,
    ) -> Result<Self, UploadError> {
        let endpoint = endpoint.into();
        validate_upload_endpoint(&endpoint)?;

        Ok(Self {
            endpoint,
            policy,
            transport,
        })
    }

    /// Builds deterministic idempotency key for a payload.
    pub fn idempotency_key(&self, payload: &MosaicPayload) -> String {
        idempotency_key_for_payload(payload)
    }

    /// Creates upload envelope for one payload/token pair.
    ///
    /// # Errors
    /// Returns [`UploadError::MissingToken`] when token is blank.
    pub fn build_envelope(
        &self,
        payload: &MosaicPayload,
        token: &str,
    ) -> Result<UploadEnvelope, UploadError> {
        if token.trim().is_empty() {
            return Err(UploadError::MissingToken);
        }

        let body = payload
            .to_json_bytes()
            .map_err(|error| UploadError::Serialize(error.to_string()))?;

        Ok(UploadEnvelope {
            endpoint: self.endpoint.clone(),
            authorization_header: format!("Bearer {token}"),
            idempotency_key: self.idempotency_key(payload),
            body,
        })
    }

    /// Uploads payload with retry policy and failure classification.
    ///
    /// # Errors
    /// Returns final upload error when retries are exhausted or failure is
    /// classified permanent.
    pub fn upload_payload(
        &self,
        payload: &MosaicPayload,
        token: &str,
    ) -> Result<UploadReport, UploadError> {
        let envelope = self.build_envelope(payload, token)?;

        let mut attempts = 0_u32;
        loop {
            attempts = attempts.saturating_add(1);

            match self.transport.send(&envelope) {
                Ok(()) => {
                    return Ok(UploadReport {
                        attempts,
                        final_class: None,
                    });
                }
                Err(error) => {
                    let failure_class = classify_upload_error(&error);
                    let exhausted = attempts > self.policy.max_retries;
                    if failure_class == FailureClass::Permanent || exhausted {
                        return Err(error);
                    }

                    // In production this is where async sleep/backoff occurs.
                    let _next_delay = self.policy.backoff_delay_ms(attempts - 1);
                }
            }
        }
    }

    /// Returns configured endpoint string.
    pub fn endpoint(&self) -> &str {
        &self.endpoint
    }

    /// Returns retry policy snapshot.
    pub fn policy(&self) -> RetryPolicy {
        self.policy
    }
}

/// Validates ingest endpoint policy.
///
/// # Errors
/// Returns [`UploadError::InvalidEndpoint`] for malformed URLs.
/// Returns [`UploadError::NonHttpsEndpoint`] for non-HTTPS URLs.
pub fn validate_upload_endpoint(endpoint: &str) -> Result<(), UploadError> {
    let parsed = Url::parse(endpoint)
        .map_err(|error| UploadError::InvalidEndpoint(format!("invalid url: {error}")))?;

    if parsed.scheme() != "https" {
        return Err(UploadError::NonHttpsEndpoint);
    }

    Ok(())
}

/// Classifies upload failures into retry/non-retry classes.
pub fn classify_upload_error(error: &UploadError) -> FailureClass {
    match error {
        UploadError::Timeout | UploadError::Server(_) | UploadError::Transport(_) => {
            FailureClass::Retriable
        }
        UploadError::InvalidEndpoint(_)
        | UploadError::NonHttpsEndpoint
        | UploadError::MissingToken
        | UploadError::Unauthorized
        | UploadError::Client(_)
        | UploadError::Serialize(_) => FailureClass::Permanent,
    }
}

/// Generates deterministic SHA-256 idempotency key.
pub fn idempotency_key_for_payload(payload: &MosaicPayload) -> String {
    let mut hasher = Sha256::new();
    hasher.update(payload.schema_version.as_bytes());
    hasher.update(payload.metadata.session_id.as_bytes());
    hasher.update(payload.metadata.screen_id.as_bytes());
    hasher.update(payload.metadata.start_timestamp_ms.to_le_bytes());
    hasher.update(payload.metadata.end_timestamp_ms.to_le_bytes());
    hasher.update(payload.mosaic_width.to_le_bytes());
    hasher.update(payload.mosaic_height.to_le_bytes());
    hasher.update(&payload.mosaic_rgba);
    hex::encode(hasher.finalize())
}

/// Upload client errors.
#[derive(Debug, Error, Clone, PartialEq, Eq)]
pub enum UploadError {
    /// Endpoint URL is malformed.
    #[error("invalid upload endpoint: {0}")]
    InvalidEndpoint(String),
    /// Endpoint must be HTTPS.
    #[error("upload endpoint must use https")]
    NonHttpsEndpoint,
    /// Bearer token is required for upload.
    #[error("upload token is missing")]
    MissingToken,
    /// Unauthorized response from API.
    #[error("upload unauthorized")]
    Unauthorized,
    /// Request timed out.
    #[error("upload timed out")]
    Timeout,
    /// Server-side failure.
    #[error("upload server failure: {0}")]
    Server(u16),
    /// Client-side non-retriable failure.
    #[error("upload client failure: {0}")]
    Client(u16),
    /// Generic transport failure.
    #[error("upload transport failure: {0}")]
    Transport(String),
    /// Payload serialization failed.
    #[error("payload serialization failure: {0}")]
    Serialize(String),
}

#[cfg(test)]
mod tests {
    //! Unit tests for retry policy and error classification.

    use super::*;

    #[test]
    fn timeout_is_retriable() {
        assert_eq!(
            classify_upload_error(&UploadError::Timeout),
            FailureClass::Retriable
        );
    }

    #[test]
    fn client_error_is_permanent() {
        assert_eq!(
            classify_upload_error(&UploadError::Client(400)),
            FailureClass::Permanent
        );
    }
}
